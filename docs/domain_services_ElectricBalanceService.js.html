<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: domain/services/ElectricBalanceService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: domain/services/ElectricBalanceService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file ElectricBalanceService.js
 * @description Servicio de dominio para la gestión del balance eléctrico
 *
 * Este servicio encapsula la lógica de negocio relacionada con el balance eléctrico,
 * coordinando operaciones que pueden involucrar múltiples entidades o reglas complejas.
 */

/**
 * Servicio para gestionar la lógica de negocio del balance eléctrico
 */
class ElectricBalanceService {
    /**
     * Crea una nueva instancia del servicio
     *
     * @param {import('../repositories/ElectricBalanceRepository')} electricBalanceRepository - Repositorio de balance eléctrico
     */
    constructor(electricBalanceRepository) {
        this.electricBalanceRepository = electricBalanceRepository;
    }

    /**
     * Analiza los datos de balance eléctrico para un rango de fechas
     *
     * @param {Date} startDate - Fecha inicial
     * @param {Date} endDate - Fecha final
     * @param {string} timeScope - Alcance temporal (day, month, year)
     * @returns {Promise&lt;Object>} - Análisis completo del balance eléctrico
     * @throws {Error} - Si hay problemas al obtener o procesar los datos
     */
    async analyzeBalanceDataByDateRange(startDate, endDate, timeScope = 'day') {
        const balanceData = await this.electricBalanceRepository.findByDateRange(
            startDate,
            endDate,
            timeScope
        );

        // Si no hay datos en el rango especificado
        if (!balanceData || balanceData.length === 0) {
            return {
                isEmpty: true,
                period: { startDate, endDate, timeScope },
                message: 'No data available for the specified date range'
            };
        }

        // Cálculo de estadísticas generales
        const totalGeneration = balanceData.reduce((sum, balance) =>
            sum + balance.getTotalGeneration(), 0);

        const totalDemand = balanceData.reduce((sum, balance) =>
            sum + balance.getTotalDemand(), 0);

        const averageRenewablePercentage = balanceData.reduce((sum, balance) =>
            sum + balance.getRenewablePercentage(), 0) / balanceData.length;

        // Análisis de distribución de generación por tipos
        const generationByType = this._aggregateGenerationByType(balanceData);

        // Análisis de tendencias temporales
        const trends = this._analyzeTrends(balanceData);

        // Composición del resultado final
        return {
            isEmpty: false,
            period: { startDate, endDate, timeScope },
            summary: {
                totalGeneration,
                totalDemand,
                netBalance: totalGeneration - totalDemand,
                averageRenewablePercentage,
                dataPoints: balanceData.length
            },
            generationDistribution: generationByType,
            timeSeries: this._createTimeSeries(balanceData),
            trends,
            rawData: balanceData.map(balance => balance.toJSON())
        };
    }

    /**
     * Compara dos períodos de tiempo para identificar cambios y tendencias
     *
     * @param {Date} currentPeriodStart - Inicio del período actual
     * @param {Date} currentPeriodEnd - Fin del período actual
     * @param {Date} previousPeriodStart - Inicio del período anterior
     * @param {Date} previousPeriodEnd - Fin del período anterior
     * @param {string} timeScope - Alcance temporal (day, month, year)
     * @returns {Promise&lt;Object>} - Análisis comparativo entre períodos
     * @throws {Error} - Si hay problemas al obtener o procesar los datos
     */
    async comparePeriods(
        currentPeriodStart,
        currentPeriodEnd,
        previousPeriodStart,
        previousPeriodEnd,
        timeScope = 'day'
    ) {
        // Obtener datos para ambos períodos
        const [currentPeriodData, previousPeriodData] = await Promise.all([
            this.electricBalanceRepository.findByDateRange(currentPeriodStart, currentPeriodEnd, timeScope),
            this.electricBalanceRepository.findByDateRange(previousPeriodStart, previousPeriodEnd, timeScope)
        ]);

        // Cálculos para el período actual
        const currentTotalGeneration = currentPeriodData.reduce((sum, balance) =>
            sum + balance.getTotalGeneration(), 0);
        const currentTotalDemand = currentPeriodData.reduce((sum, balance) =>
            sum + balance.getTotalDemand(), 0);
        const currentRenewablePercentage = currentPeriodData.reduce((sum, balance) =>
            sum + balance.getRenewablePercentage(), 0) / currentPeriodData.length;

        // Cálculos para el período anterior
        const previousTotalGeneration = previousPeriodData.reduce((sum, balance) =>
            sum + balance.getTotalGeneration(), 0);
        const previousTotalDemand = previousPeriodData.reduce((sum, balance) =>
            sum + balance.getTotalDemand(), 0);
        const previousRenewablePercentage = previousPeriodData.reduce((sum, balance) =>
            sum + balance.getRenewablePercentage(), 0) / previousPeriodData.length;

        // Cálculo de cambios porcentuales
        const generationChange = this._calculatePercentageChange(
            currentTotalGeneration,
            previousTotalGeneration
        );
        const demandChange = this._calculatePercentageChange(
            currentTotalDemand,
            previousTotalDemand
        );
        const renewableChange = this._calculatePercentageChange(
            currentRenewablePercentage,
            previousRenewablePercentage
        );

        // Análisis de cambios en la distribución de generación
        const currentGenerationByType = this._aggregateGenerationByType(currentPeriodData);
        const previousGenerationByType = this._aggregateGenerationByType(previousPeriodData);
        const generationTypeChanges = this._compareGenerationDistributions(
            currentGenerationByType,
            previousGenerationByType
        );

        return {
            currentPeriod: {
                start: currentPeriodStart,
                end: currentPeriodEnd,
                dataPoints: currentPeriodData.length
            },
            previousPeriod: {
                start: previousPeriodStart,
                end: previousPeriodEnd,
                dataPoints: previousPeriodData.length
            },
            changes: {
                generation: {
                    current: currentTotalGeneration,
                    previous: previousTotalGeneration,
                    percentageChange: generationChange,
                    trend: generationChange > 0 ? 'increase' : 'decrease'
                },
                demand: {
                    current: currentTotalDemand,
                    previous: previousTotalDemand,
                    percentageChange: demandChange,
                    trend: demandChange > 0 ? 'increase' : 'decrease'
                },
                renewablePercentage: {
                    current: currentRenewablePercentage,
                    previous: previousRenewablePercentage,
                    percentageChange: renewableChange,
                    trend: renewableChange > 0 ? 'increase' : 'decrease'
                },
                generationTypes: generationTypeChanges
            }
        };
    }

    /**
     * Calcula métricas de sostenibilidad basadas en los datos de balance eléctrico
     *
     * @param {Date} startDate - Fecha inicial
     * @param {Date} endDate - Fecha final
     * @param {string} timeScope - Alcance temporal (day, month, year)
     * @returns {Promise&lt;Object>} - Métricas de sostenibilidad
     * @throws {Error} - Si hay problemas al obtener o procesar los datos
     */
    async calculateSustainabilityMetrics(startDate, endDate, timeScope = 'day') {
        const balanceData = await this.electricBalanceRepository.findByDateRange(
            startDate,
            endDate,
            timeScope
        );

        if (!balanceData || balanceData.length === 0) {
            return {
                isEmpty: true,
                period: { startDate, endDate, timeScope },
                message: 'No data available for the specified date range'
            };
        }

        // Clasificación de fuentes de energía
        const renewableTypes = [
            'Hidráulica', 'Eólica', 'Solar fotovoltaica', 'Solar térmica',
            'Otras renovables', 'Hidroeólica'
        ];

        const lowCarbonTypes = [
            ...renewableTypes, 'Nuclear'
        ];

        // Cálculo de métricas
        let totalGeneration = 0;
        let renewableGeneration = 0;
        let lowCarbonGeneration = 0;

        for (const balance of balanceData) {
            const generationTotal = balance.getTotalGeneration();
            totalGeneration += generationTotal;

            for (const gen of balance.generation) {
                if (renewableTypes.includes(gen.type)) {
                    renewableGeneration += gen.value;
                }

                if (lowCarbonTypes.includes(gen.type)) {
                    lowCarbonGeneration += gen.value;
                }
            }
        }

        // Cálculo de porcentajes
        const renewablePercentage = (renewableGeneration / totalGeneration) * 100;
        const lowCarbonPercentage = (lowCarbonGeneration / totalGeneration) * 100;

        // Estimación de CO2 evitado (aproximación simplificada)
        // Asumiendo que 1 MWh de energía no renovable emite ~0.5 toneladas de CO2
        const hoursInPeriod = (endDate - startDate) / (1000 * 60 * 60);
        const co2Avoided = (renewableGeneration * hoursInPeriod * 0.5) / 1000; // en toneladas

        return {
            isEmpty: false,
            period: { startDate, endDate, timeScope },
            metrics: {
                totalGeneration,
                renewableGeneration,
                lowCarbonGeneration,
                renewablePercentage,
                lowCarbonPercentage,
                co2AvoidedEstimation: co2Avoided,
                sustainabilityScore: this._calculateSustainabilityScore(
                    renewablePercentage,
                    lowCarbonPercentage
                )
            },
            dailyTrend: this._calculateDailyTrend(balanceData, renewableTypes, lowCarbonTypes)
        };
    }

    /**
     * Identifica patrones y anomalías en los datos de balance eléctrico
     *
     * @param {Date} startDate - Fecha inicial
     * @param {Date} endDate - Fecha final
     * @param {string} timeScope - Alcance temporal (day, month, year)
     * @returns {Promise&lt;Object>} - Patrones y anomalías detectados
     * @throws {Error} - Si hay problemas al obtener o procesar los datos
     */
    async detectPatternsAndAnomalies(startDate, endDate, timeScope = 'day') {
        const balanceData = await this.electricBalanceRepository.findByDateRange(
            startDate,
            endDate,
            timeScope
        );

        if (!balanceData || balanceData.length === 0) {
            return {
                isEmpty: true,
                period: { startDate, endDate, timeScope },
                message: 'No data available for the specified date range'
            };
        }

        // Extracción de series temporales para análisis
        const generationSeries = balanceData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getTotalGeneration()
        }));

        const demandSeries = balanceData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getTotalDemand()
        }));

        const renewableSeries = balanceData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getRenewablePercentage()
        }));

        // Detección de anomalías (valores fuera de +/- 2 desviaciones estándar)
        const generationAnomalies = this._detectAnomalies(generationSeries);
        const demandAnomalies = this._detectAnomalies(demandSeries);
        const renewableAnomalies = this._detectAnomalies(renewableSeries);

        // Detección de patrones cíclicos (simplificado)
        const cyclicalPatterns = this._detectCyclicalPatterns(demandSeries);

        return {
            isEmpty: false,
            period: { startDate, endDate, timeScope },
            anomalies: {
                generation: generationAnomalies,
                demand: demandAnomalies,
                renewablePercentage: renewableAnomalies
            },
            patterns: {
                cyclical: cyclicalPatterns,
                correlations: this._detectCorrelations(balanceData)
            }
        };
    }

    /**
     * Agrega datos de generación por tipo
     *
     * @param {Array&lt;import('../entities/ElectricBalance')>} balanceData - Datos de balance eléctrico
     * @returns {Object} - Datos agregados por tipo de generación
     * @private
     */
    _aggregateGenerationByType(balanceData) {
        // Inicializar el objeto para acumular valores por tipo
        const aggregatedByType = {};

        // Recorrer todos los balances y acumular valores por tipo
        for (const balance of balanceData) {
            for (const genItem of balance.generation) {
                const { type, value, color } = genItem;

                if (!aggregatedByType[type]) {
                    aggregatedByType[type] = {
                        totalValue: 0,
                        percentage: 0,
                        color
                    };
                }

                aggregatedByType[type].totalValue += value;
            }
        }

        // Calcular el total global para los porcentajes
        const totalGeneration = Object.values(aggregatedByType)
            .reduce((sum, item) => sum + item.totalValue, 0);

        // Actualizar porcentajes
        for (const type in aggregatedByType) {
            aggregatedByType[type].percentage =
                (aggregatedByType[type].totalValue / totalGeneration) * 100;
        }

        return aggregatedByType;
    }

    /**
     * Analiza tendencias en los datos de balance eléctrico
     *
     * @param {Array&lt;import('../entities/ElectricBalance')>} balanceData - Datos de balance eléctrico
     * @returns {Object} - Análisis de tendencias
     * @private
     */
    _analyzeTrends(balanceData) {
        // Verificar que hay suficientes datos para analizar tendencias
        if (balanceData.length &lt; 2) {
            return {
                insufficient: true,
                message: 'Insufficient data points to analyze trends'
            };
        }

        // Ordenar datos por fecha
        const sortedData = [...balanceData].sort((a, b) =>
            a.timestamp.getTime() - b.timestamp.getTime());

        // Extraer series temporales para cada indicador
        const generationValues = sortedData.map(b => b.getTotalGeneration());
        const demandValues = sortedData.map(b => b.getTotalDemand());
        const renewableValues = sortedData.map(b => b.getRenewablePercentage());

        // Calcular pendientes simples para determinar tendencias
        const generationTrend = this._calculateTrend(generationValues);
        const demandTrend = this._calculateTrend(demandValues);
        const renewableTrend = this._calculateTrend(renewableValues);

        return {
            generation: {
                trend: generationTrend > 0 ? 'upward' : generationTrend &lt; 0 ? 'downward' : 'stable',
                slope: generationTrend,
                startValue: generationValues[0],
                endValue: generationValues[generationValues.length - 1],
                changePercentage: this._calculatePercentageChange(
                    generationValues[generationValues.length - 1],
                    generationValues[0]
                )
            },
            demand: {
                trend: demandTrend > 0 ? 'upward' : demandTrend &lt; 0 ? 'downward' : 'stable',
                slope: demandTrend,
                startValue: demandValues[0],
                endValue: demandValues[demandValues.length - 1],
                changePercentage: this._calculatePercentageChange(
                    demandValues[demandValues.length - 1],
                    demandValues[0]
                )
            },
            renewablePercentage: {
                trend: renewableTrend > 0 ? 'upward' : renewableTrend &lt; 0 ? 'downward' : 'stable',
                slope: renewableTrend,
                startValue: renewableValues[0],
                endValue: renewableValues[renewableValues.length - 1],
                changePercentage: this._calculatePercentageChange(
                    renewableValues[renewableValues.length - 1],
                    renewableValues[0]
                )
            }
        };
    }

    /**
     * Crea series temporales para visualización
     *
     * @param {Array&lt;import('../entities/ElectricBalance')>} balanceData - Datos de balance eléctrico
     * @returns {Object} - Series temporales para cada indicador principal
     * @private
     */
    _createTimeSeries(balanceData) {
        // Ordenar datos por fecha
        const sortedData = [...balanceData].sort((a, b) =>
            a.timestamp.getTime() - b.timestamp.getTime());

        // Crear series para cada indicador principal
        const generation = sortedData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getTotalGeneration()
        }));

        const demand = sortedData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getTotalDemand()
        }));

        const renewablePercentage = sortedData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getRenewablePercentage()
        }));

        const balance = sortedData.map(balance => ({
            timestamp: balance.timestamp,
            value: balance.getBalance()
        }));

        // Crear series para tipos específicos de generación
        const generationByType = {};

        // Inicializar tipos de generación
        if (sortedData.length > 0) {
            const firstBalance = sortedData[0];
            for (const gen of firstBalance.generation) {
                generationByType[gen.type] = [];
            }

            // Rellenar series por cada tipo
            for (const balance of sortedData) {
                for (const gen of balance.generation) {
                    generationByType[gen.type].push({
                        timestamp: balance.timestamp,
                        value: gen.value,
                        percentage: gen.percentage
                    });
                }
            }
        }

        return {
            totalGeneration: generation,
            totalDemand: demand,
            renewablePercentage: renewablePercentage,
            balance: balance,
            generationByType: generationByType
        };
    }

    /**
     * Calcula el cambio porcentual entre dos valores
     *
     * @param {number} current - Valor actual
     * @param {number} previous - Valor anterior
     * @returns {number} - Cambio porcentual
     * @private
     */
    _calculatePercentageChange(current, previous) {
        if (previous === 0) return current > 0 ? 100 : 0;
        return ((current - previous) / Math.abs(previous)) * 100;
    }

    /**
     * Compara distribuciones de generación entre períodos
     *
     * @param {Object} currentDist - Distribución actual
     * @param {Object} previousDist - Distribución anterior
     * @returns {Array&lt;Object>} - Cambios por tipo de generación
     * @private
     */
    _compareGenerationDistributions(currentDist, previousDist) {
        const changes = [];

        // Unir todos los tipos de ambas distribuciones
        const allTypes = new Set([
            ...Object.keys(currentDist),
            ...Object.keys(previousDist)
        ]);

        for (const type of allTypes) {
            const current = currentDist[type] || { totalValue: 0, percentage: 0 };
            const previous = previousDist[type] || { totalValue: 0, percentage: 0 };

            changes.push({
                type,
                currentValue: current.totalValue,
                previousValue: previous.totalValue,
                currentPercentage: current.percentage,
                previousPercentage: previous.percentage,
                valueChange: current.totalValue - previous.totalValue,
                percentageChange: current.percentage - previous.percentage,
                percentageChangeRelative: this._calculatePercentageChange(
                    current.percentage,
                    previous.percentage
                ),
                color: current.color || previous.color
            });
        }

        // Ordenar por cambio relativo de mayor a menor
        return changes.sort((a, b) =>
            Math.abs(b.percentageChangeRelative) - Math.abs(a.percentageChangeRelative));
    }

    /**
     * Calcula la tendencia (pendiente) de una serie de valores
     *
     * @param {Array&lt;number>} values - Serie de valores
     * @returns {number} - Tendencia (pendiente)
     * @private
     */
    _calculateTrend(values) {
        if (values.length &lt; 2) return 0;

        // Simplificación del cálculo de tendencia usando la pendiente entre
        // el primer y último punto
        return (values[values.length - 1] - values[0]) / (values.length - 1);
    }

    /**
     * Calcula una puntuación de sostenibilidad
     *
     * @param {number} renewablePercentage - Porcentaje de renovables
     * @param {number} lowCarbonPercentage - Porcentaje de bajas emisiones
     * @returns {number} - Puntuación (0-100)
     * @private
     */
    _calculateSustainabilityScore(renewablePercentage, lowCarbonPercentage) {
        // Fórmula simple: 70% peso para renovables, 30% para bajas emisiones
        return (renewablePercentage * 0.7) +
            ((lowCarbonPercentage - renewablePercentage) * 0.3);
    }

    /**
     * Calcula la tendencia diaria de renovables y bajas emisiones
     *
     * @param {Array&lt;import('../entities/ElectricBalance')>} balanceData - Datos de balance
     * @param {Array&lt;string>} renewableTypes - Tipos de generación renovable
     * @param {Array&lt;string>} lowCarbonTypes - Tipos de generación de bajas emisiones
     * @returns {Array&lt;Object>} - Tendencia diaria
     * @private
     */
    _calculateDailyTrend(balanceData, renewableTypes, lowCarbonTypes) {
        const sortedData = [...balanceData].sort((a, b) =>
            a.timestamp.getTime() - b.timestamp.getTime());

        return sortedData.map(balance => {
            let totalGen = balance.getTotalGeneration();
            let renewableGen = 0;
            let lowCarbonGen = 0;

            for (const gen of balance.generation) {
                if (renewableTypes.includes(gen.type)) {
                    renewableGen += gen.value;
                }

                if (lowCarbonTypes.includes(gen.type)) {
                    lowCarbonGen += gen.value;
                }
            }

            return {
                date: balance.timestamp,
                totalGeneration: totalGen,
                renewableGeneration: renewableGen,
                lowCarbonGeneration: lowCarbonGen,
                renewablePercentage: (renewableGen / totalGen) * 100,
                lowCarbonPercentage: (lowCarbonGen / totalGen) * 100
            };
        });
    }

    /**
     * Detecta anomalías en una serie temporal
     *
     * @param {Array&lt;Object>} series - Serie temporal con timestamp y value
     * @returns {Array&lt;Object>} - Anomalías detectadas
     * @private
     */
    _detectAnomalies(series) {
        if (series.length &lt; 3) return [];

        // Calcular media y desviación estándar
        const values = series.map(point => point.value);
        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;

        const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
        const variance = squaredDiffs.reduce((sum, v) => sum + v, 0) / values.length;
        const stdDev = Math.sqrt(variance);

        // Buscar valores fuera de 2 desviaciones estándar
        const anomalies = [];

        for (let i = 0; i &lt; series.length; i++) {
            const point = series[i];
            const zScore = Math.abs((point.value - mean) / stdDev);

            if (zScore > 2) {
                anomalies.push({
                    timestamp: point.timestamp,
                    value: point.value,
                    mean,
                    deviation: point.value - mean,
                    zScore,
                    type: point.value > mean ? 'high' : 'low'
                });
            }
        }

        return anomalies;
    }

    /**
     * Detecta patrones cíclicos en una serie temporal
     *
     * @param {Array&lt;Object>} series - Serie temporal con timestamp y value
     * @returns {Object} - Patrones cíclicos detectados (simplificado)
     * @private
     */
    _detectCyclicalPatterns(series) {
        if (series.length &lt; 7) {
            return { detected: false, reason: 'Insufficient data points' };
        }

        // Simplificación para detectar patrones diarios/semanales
        const dailyPattern = this._checkDailyPattern(series);
        const weeklyPattern = this._checkWeeklyPattern(series);

        return {
            detected: dailyPattern.detected || weeklyPattern.detected,
            daily: dailyPattern,
            weekly: weeklyPattern
        };
    }

    /**
     * Comprueba patrones diarios (simplificado)
     *
     * @param {Array&lt;Object>} series - Serie temporal
     * @returns {Object} - Información del patrón
     * @private
     */
    _checkDailyPattern(series) {
        // Implementación simplificada
        return {
            detected: false,
            message: 'Daily pattern detection requires hourly data'
        };
    }

    /**
     * Comprueba patrones semanales (simplificado)
     *
     * @param {Array&lt;Object>} series - Serie temporal
     * @returns {Object} - Información del patrón
     * @private
     */
    _checkWeeklyPattern(series) {
        // Agrupar por día de la semana
        const byDayOfWeek = [0, 0, 0, 0, 0, 0, 0]; // Domingo a Sábado
        const counts = [0, 0, 0, 0, 0, 0, 0];

        for (const point of series) {
            const dayOfWeek = new Date(point.timestamp).getDay();
            byDayOfWeek[dayOfWeek] += point.value;
            counts[dayOfWeek]++;
        }

        // Calcular promedios por día
        const averagesByDay = byDayOfWeek.map((sum, i) =>
            counts[i] > 0 ? sum / counts[i] : 0);

        // Calcular varianza entre días para ver si hay un patrón claro
        const avgOfAvgs = averagesByDay.reduce((sum, v) => sum + v, 0) / 7;
        const variance = averagesByDay.reduce(
            (sum, v) => sum + Math.pow(v - avgOfAvgs, 2), 0) / 7;

        // Si hay suficiente varianza, consideramos que hay un patrón
        const weekdayLabels = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
        const patternStrength = Math.sqrt(variance) / avgOfAvgs;

        return {
            detected: patternStrength > 0.1,
            strength: patternStrength,
            averagesByDay: averagesByDay.map((avg, i) => ({
                day: weekdayLabels[i],
                average: avg
            })),
            highestDay: weekdayLabels[averagesByDay.indexOf(Math.max(...averagesByDay))],
            lowestDay: weekdayLabels[averagesByDay.indexOf(Math.min(...averagesByDay))]
        };
    }

    /**
     * Detecta correlaciones entre diferentes métricas
     *
     * @param {Array&lt;import('../entities/ElectricBalance')>} balanceData - Datos de balance
     * @returns {Array&lt;Object>} - Correlaciones detectadas
     * @private
     */
    _detectCorrelations(balanceData) {
        // Extraer series para diferentes métricas
        const totalDemand = balanceData.map(b => b.getTotalDemand());
        const totalGeneration = balanceData.map(b => b.getTotalGeneration());
        const renewablePercentage = balanceData.map(b => b.getRenewablePercentage());

        // Calcular correlaciones simples
        const demandVsGeneration = this._calculateCorrelation(totalDemand, totalGeneration);
        const demandVsRenewable = this._calculateCorrelation(totalDemand, renewablePercentage);
        const generationVsRenewable = this._calculateCorrelation(totalGeneration, renewablePercentage);

        return [
            {
                between: ['Demanda', 'Generación'],
                correlation: demandVsGeneration,
                strength: this._describeCorrelationStrength(demandVsGeneration),
                direction: demandVsGeneration > 0 ? 'positiva' : 'negativa'
            },
            {
                between: ['Demanda', 'Porcentaje renovable'],
                correlation: demandVsRenewable,
                strength: this._describeCorrelationStrength(demandVsRenewable),
                direction: demandVsRenewable > 0 ? 'positiva' : 'negativa'
            },
            {
                between: ['Generación', 'Porcentaje renovable'],
                correlation: generationVsRenewable,
                strength: this._describeCorrelationStrength(generationVsRenewable),
                direction: generationVsRenewable > 0 ? 'positiva' : 'negativa'
            }
        ];
    }

    /**
     * Calcula la correlación entre dos series
     *
     * @param {Array&lt;number>} seriesA - Primera serie de valores
     * @param {Array&lt;number>} seriesB - Segunda serie de valores
     * @returns {number} - Coeficiente de correlación
     * @private
     */
    _calculateCorrelation(seriesA, seriesB) {
        if (seriesA.length !== seriesB.length || seriesA.length &lt; 2) {
            return 0;
        }

        // Calcular medias
        const meanA = seriesA.reduce((sum, val) => sum + val, 0) / seriesA.length;
        const meanB = seriesB.reduce((sum, val) => sum + val, 0) / seriesB.length;

        // Calcular covarianza y varianzas
        let covariance = 0;
        let varianceA = 0;
        let varianceB = 0;

        for (let i = 0; i &lt; seriesA.length; i++) {
            const diffA = seriesA[i] - meanA;
            const diffB = seriesB[i] - meanB;

            covariance += diffA * diffB;
            varianceA += diffA * diffA;
            varianceB += diffB * diffB;
        }

        // Evitar división por cero
        if (varianceA === 0 || varianceB === 0) {
            return 0;
        }

        return covariance / (Math.sqrt(varianceA) * Math.sqrt(varianceB));
    }

    /**
     * Describe la fuerza de una correlación
     *
     * @param {number} correlation - Coeficiente de correlación
     * @returns {string} - Descripción cualitativa
     * @private
     */
    _describeCorrelationStrength(correlation) {
        const absCorr = Math.abs(correlation);

        if (absCorr &lt; 0.2) return 'muy débil';
        if (absCorr &lt; 0.4) return 'débil';
        if (absCorr &lt; 0.6) return 'moderada';
        if (absCorr &lt; 0.8) return 'fuerte';
        return 'muy fuerte';
    }

    /**
     * Obtiene los picos y valles en un rango de fechas
     *
     * @param {Date} startDate - Fecha inicial
     * @param {Date} endDate - Fecha final
     * @param {string} timeScope - Alcance temporal (day, month, year)
     * @param {string} metric - Métrica a analizar (generation, demand, renewable)
     * @returns {Promise&lt;Object>} - Picos y valles detectados
     * @throws {Error} - Si hay problemas al obtener o procesar los datos
     */
    async getPeaksAndValleys(startDate, endDate, timeScope = 'day', metric = 'demand') {
        const balanceData = await this.electricBalanceRepository.findByDateRange(
            startDate,
            endDate,
            timeScope
        );

        if (!balanceData || balanceData.length &lt; 3) {
            return {
                isEmpty: true,
                message: 'Insufficient data to detect peaks and valleys'
            };
        }

        // Ordenar los datos por fecha
        const sortedData = [...balanceData].sort((a, b) =>
            a.timestamp.getTime() - b.timestamp.getTime());

        // Extraer los valores según la métrica seleccionada
        const series = sortedData.map(balance => {
            let value;

            switch (metric) {
                case 'generation':
                    value = balance.getTotalGeneration();
                    break;
                case 'renewable':
                    value = balance.getRenewablePercentage();
                    break;
                case 'demand':
                default:
                    value = balance.getTotalDemand();
                    break;
            }

            return {
                timestamp: balance.timestamp,
                value
            };
        });

        // Detectar picos (máximos locales)
        const peaks = [];
        for (let i = 1; i &lt; series.length - 1; i++) {
            if (series[i].value > series[i - 1].value &amp;&amp; series[i].value > series[i + 1].value) {
                peaks.push({
                    timestamp: series[i].timestamp,
                    value: series[i].value,
                    index: i
                });
            }
        }

        // Detectar valles (mínimos locales)
        const valleys = [];
        for (let i = 1; i &lt; series.length - 1; i++) {
            if (series[i].value &lt; series[i - 1].value &amp;&amp; series[i].value &lt; series[i + 1].value) {
                valleys.push({
                    timestamp: series[i].timestamp,
                    value: series[i].value,
                    index: i
                });
            }
        }

        // Añadir extremos si son relevantes
        if (series.length > 0) {
            // Añadir primer punto si es un extremo
            if (series[0].value > series[1].value) {
                peaks.push({
                    timestamp: series[0].timestamp,
                    value: series[0].value,
                    index: 0
                });
            } else if (series[0].value &lt; series[1].value) {
                valleys.push({
                    timestamp: series[0].timestamp,
                    value: series[0].value,
                    index: 0
                });
            }

            // Añadir último punto si es un extremo
            const last = series.length - 1;
            if (series[last].value > series[last - 1].value) {
                peaks.push({
                    timestamp: series[last].timestamp,
                    value: series[last].value,
                    index: last
                });
            } else if (series[last].value &lt; series[last - 1].value) {
                valleys.push({
                    timestamp: series[last].timestamp,
                    value: series[last].value,
                    index: last
                });
            }
        }

        // Ordenar picos y valles por valor
        peaks.sort((a, b) => b.value - a.value);
        valleys.sort((a, b) => a.value - b.value);

        // Calcular estadísticas
        const values = series.map(point => point.value);
        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
        const max = Math.max(...values);
        const min = Math.min(...values);

        return {
            isEmpty: false,
            metric,
            period: { startDate, endDate, timeScope },
            statistics: {
                mean,
                max,
                min,
                range: max - min,
                count: series.length
            },
            peaks: peaks.slice(0, 5), // Top 5 picos
            valleys: valleys.slice(0, 5), // Top 5 valles
            timeSeries: series
        };
    }
}

module.exports = ElectricBalanceService;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ApiRequestError.html">ApiRequestError</a></li><li><a href="ApiResponseError.html">ApiResponseError</a></li><li><a href="ApplicationError.html">ApplicationError</a></li><li><a href="BusinessRuleViolationError.html">BusinessRuleViolationError</a></li><li><a href="ConfigurationError.html">ConfigurationError</a></li><li><a href="DuplicateDataError.html">DuplicateDataError</a></li><li><a href="ElectricBalance.html">ElectricBalance</a></li><li><a href="ElectricBalanceController.html">ElectricBalanceController</a></li><li><a href="ElectricBalanceService.html">ElectricBalanceService</a></li><li><a href="ExternalResourceError.html">ExternalResourceError</a></li><li><a href="FetchREEData.html">FetchREEData</a></li><li><a href="GetElectricBalanceByDateRange.html">GetElectricBalanceByDateRange</a></li><li><a href="InvalidDataError.html">InvalidDataError</a></li><li><a href="InvalidDateRangeError.html">InvalidDateRangeError</a></li><li><a href="MongoElectricBalanceRepository.html">MongoElectricBalanceRepository</a></li><li><a href="NetworkError.html">NetworkError</a></li><li><a href="NotAuthorizedError.html">NotAuthorizedError</a></li><li><a href="NotFoundError.html">NotFoundError</a></li><li><a href="REEApiService.html">REEApiService</a></li><li><a href="REEDataFetcher.html">REEDataFetcher</a></li><li><a href="RepositoryError.html">RepositoryError</a></li><li><a href="SchedulerManager.html">SchedulerManager</a></li><li><a href="StoreElectricBalanceData.html">StoreElectricBalanceData</a></li><li><a href="ValidationError.html">ValidationError</a></li></ul><h3>Interfaces</h3><ul><li><a href="ElectricBalanceRepository.html">ElectricBalanceRepository</a></li></ul><h3>Global</h3><ul><li><a href="global.html#MongoConnection">MongoConnection</a></li><li><a href="global.html#balanceItemSchema">balanceItemSchema</a></li><li><a href="global.html#bootstrap">bootstrap</a></li><li><a href="global.html#compareDatesIgnoringTime">compareDatesIgnoringTime</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#connectToDatabase">connectToDatabase</a></li><li><a href="global.html#createComponentLogger">createComponentLogger</a></li><li><a href="global.html#createGraphQLLogger">createGraphQLLogger</a></li><li><a href="global.html#createGraphQLServer">createGraphQLServer</a></li><li><a href="global.html#createTransports">createTransports</a></li><li><a href="global.html#determineMongoErrorCode">determineMongoErrorCode</a></li><li><a href="global.html#determineTimeScope">determineTimeScope</a></li><li><a href="global.html#electricBalanceResolvers">electricBalanceResolvers</a></li><li><a href="global.html#electricBalanceSchema">electricBalanceSchema</a></li><li><a href="global.html#errorLogger">errorLogger</a></li><li><a href="global.html#errorMiddleware">errorMiddleware</a></li><li><a href="global.html#extendWithLogger">extendWithLogger</a></li><li><a href="global.html#formatDate">formatDate</a></li><li><a href="global.html#formatDateForREEApi">formatDateForREEApi</a></li><li><a href="global.html#formatDateForUI">formatDateForUI</a></li><li><a href="global.html#formatDateISO">formatDateISO</a></li><li><a href="global.html#getDateRangeForPeriod">getDateRangeForPeriod</a></li><li><a href="global.html#getEnv">getEnv</a></li><li><a href="global.html#getErrorCodeFromType">getErrorCodeFromType</a></li><li><a href="global.html#getHttpStatusFromError">getHttpStatusFromError</a></li><li><a href="global.html#getMostRecentDate">getMostRecentDate</a></li><li><a href="global.html#handleApiError">handleApiError</a></li><li><a href="global.html#handleDatabaseError">handleDatabaseError</a></li><li><a href="global.html#handleError">handleError</a></li><li><a href="global.html#handleREEApiError">handleREEApiError</a></li><li><a href="global.html#handleValidationError">handleValidationError</a></li><li><a href="global.html#initializeRepositories">initializeRepositories</a></li><li><a href="global.html#initializeSchedulers">initializeSchedulers</a></li><li><a href="global.html#initializeServices">initializeServices</a></li><li><a href="global.html#logFormats">logFormats</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#mapErrorToGraphQLError">mapErrorToGraphQLError</a></li><li><a href="global.html#parseDate">parseDate</a></li><li><a href="global.html#requestLogger">requestLogger</a></li><li><a href="global.html#setupBasicRoutes">setupBasicRoutes</a></li><li><a href="global.html#setupGracefulShutdown">setupGracefulShutdown</a></li><li><a href="global.html#setupGraphQLServer">setupGraphQLServer</a></li><li><a href="global.html#setupMiddlewares">setupMiddlewares</a></li><li><a href="global.html#toArray">toArray</a></li><li><a href="global.html#toBoolean">toBoolean</a></li><li><a href="global.html#toNumber">toNumber</a></li><li><a href="global.html#toObject">toObject</a></li><li><a href="global.html#tryListen">tryListen</a></li><li><a href="global.html#validateDateRange">validateDateRange</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun May 18 2025 00:40:17 GMT-0500 (Ecuador Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
